Nametable compression:
Clearly a 32x30 byte nametable filled with 00s is not going to work. How to compress, decompress, and write in an effective amount of time.

X and Y position within a 32x30 grid can be expressed with less than a byte, 3 or 4 bits. 4 bits can represent numbers up to 16.

First idea was something like a sparse array. My current maps use 10 tiles. (8x8) I will obviously want more than that, but water can be done with a palette swap. 

32x30 = 960 bytes.

Here is the original nametable I'm working from (not a very well-designed one, and more sparse than most would be):
NAMETABLE0: 
          ;00   01   02   03   04   05   06   07   08   09   0A   0B   0C   0D   0E   0F ; 10   11   12   13   14   15   16   17   18   19   1A   1B   1C   1D   1E   1F  
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $0C, $00, $00, $00, $00, $00 ;00
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $0B, $00, $00, $00, $00, $00 ;01
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0C, $00, $00, $00, $00, $00 ;02
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0B, $00, $00, $00, $00, $00 ;03
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0A, $00, $00, $00, $00, $00 ;04
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0C, $00, $00, $00, $00, $00 ;05
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ,$00, $00, $00, $00, $00, $08, $05, $01, $02, $01, $02, $0C, $00, $00, $00, $00, $00 ;06
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $0B, $00, $00, $00, $00, $00 ;07
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0C, $00, $00, $00 ;08
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0B, $00, $00, $00 ;09
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08, $05, $01, $02, $01, $02, $0C, $00, $00, $00 ;0A
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $0B, $00, $00, $00 ;0B
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $0C, $00, $00, $00 ;0C
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $0B, $00, $00, $00 ;0D
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0C, $00, $00, $00 ;0E
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0B, $00, $00, $00 ;0F
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0C, $00, $00, $00 ;10
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0B, $00, $00, $00 ;11
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0C, $00, $00, $00 ;12
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0B, $00, $00, $00 ;13
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0C, $0A, $0A, $00, $00, $00 ;14
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0B, $00, $00, $00, $00, $00 ;15
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $0C, $00, $00, $00, $00, $00 ;16
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $0B, $00, $00, $00, $00, $00 ;17
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $01, $02, $01, $02, $01, $02, $01, $02, $0C, $00 ;18
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $03, $04, $03, $04, $03, $04, $03, $04, $0B, $00 ;19
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $05, $01, $02, $08, $09, $01, $02, $01, $02, $0C, $09, $0A, $00 ;1A
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $06, $03, $04, $0B, $06, $03, $04, $03, $04, $0B, $00, $00, $00 ;1B
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $08, $09, $0A, $00, $08, $09, $08, $09, $0A, $00, $00, $00 ;1C
    .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ;1D


Sparse array will have an event horizon, but might work with my current maps, or similar ones. The event horizon is clearly if more than half the map is not a single tile.
Untenable.

So we must sparse array the sparse array
We can use another byte for "how many in the row". Can we use the top nibble of the ID byte?

(ID followed by (row, column) location byte pairs.)
01[00 16 00 18 02 14 02 16 02 18 04 14 04 16 04 18 06 16 06 18 08 16 08 18 08 1A 0A 18 0A 1A 0C 18 0C 1A OE 16 OE 18 OE 1A
   10 16 10 18 10 1A 12 16 12 18 12 1A 14 14 14 16 14 18 16 14 16 16 16 18 18 14 18 16 18 18 18 1A 18 1C 1A 14 1A 18 1A 1A   81 bytes

Pretty good
(ID, Row, Amt)
(High bit set means ID - 10000001 = ID 01 = $81) (1 byte for "canvas" byte. Fill nametable first, then layout the tiles)
81 [00 02 16 18] [02 03 14 16 18] [04 03 14 16 18] [06 02 16 18] [08 02 18 1A] [0A 02 18 1A] [0C 02 18 1A] [0E 03 16 18 1A] 
   [10 03 16 18 1A] [12 03 16 18 1A] [14 03 14 16 18] [16 03 14 16 18] [18 05 14 16 18 1A 1C] [1A 03 14 18 1A]		            67 bytes
82 [00 02 17 19] [02 03 15 17 19] [04 03 15 17 19] [06 02 17 19] [08 03 17 19 1B] [0A 02 19 1B] [0C 02 19 1B] [0E 03 17 19 1B] 
   [10 03 17 19 1B] [12 03 17 19 1B] [14 03 15 17 19] [16 03 15 17 19] [18 05 15 17 19 1B 1D] [1A 03 15 19 1B]                 68 bytes


Same concept, column-wise
ID, (Column, Amt, Row loc ...)
81 [14 06 02 04 14 16 18 1A] [16 0B 00 02 04 06 08 0E 10 12 14 16 18] [18 0E 00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A] 
   [1A 08 08 0A 0C 0E 10 12 18 1A] [1C 01 18]                                                                                  51 bytes
82 [15 06 02 04 14 16 18 1A] [17 0B 00 02 04 06 08 0E 10 12 14 16 18] [19 0E 00 02 04 06 08 0A 0C 0E 10 12 14 16 18 1A]
   [1B 08 08 0A 0C 0E 10 12 18 1A] [1D 01 18]										                                                    51 bytes
83 [14 06 03 05 15 17 19 1B] [16 0B 01 03 05 07 09 0F 11 13 15 17 19] [18 0E 01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B]
   [1A 08 09 0B 0C 0F 11 13 19 1B] [1C 01 19]										                                                    51 bytes
84 [15 06 03 05 15 17 19 1B] [17 0B 01 03 05 07 09 0F 11 13 15 17 19] [19 0E 01 03 05 07 09 0B 0D 0F 11 13 15 17 19 1B]
   [1B 08 09 0B 0C 0F 11 13 19 1B] [1D 01 19]                                                                                  51 bytes
85 [13 06 02 04 14 16 18 1A] [15 06 00 06 08 0E 10 12] [17 02 0A 0C]                                                           21 bytes
86 [13 06 03 05 15 17 19 0B] [15 06 01 07 09 0F 11 13] [17 03 0B 0D 1B]							                                     22 bytes
88 [14 02 06 1C] [16 02 0A 1A] [18 01 1C] [1A 01 1C]                                                                           15 bytes
89 [15 01 1C] [17 01 1A] [19 01 1C] [1B 01 1C] [1D 01 1A]								                                              16 bytes
8A [16 01 1C] [1A 01 04] [1B 01 14] [1C 02 14 1C] [1E 01 1A]								                                           17 bytes
8B [16 01 1B] [1A 05 01 03 07 15 17] [1C 07 09 0B 0D 0F 11 13 1B] [1E 01 19]						                                  23 bytes
8C [1A 06 00 02 05 06 14 16] [1C 07 08 0A 0C 0E 10 12] [1E 01 18]							                                           20 bytes
															                                                                              ------------
												                                                        Total:			                     338 bytes     
                                                                                                                        1/3 compression


Ok, apparently this is getting gitignored. bitpacking concept as follows: you only need 5 bits to make 0-31 or 0-29 (row wise or column wise)
So using 2 bytes for screen position is a waste off 6 bits. Running column-wise, the first ID $01 would be further compressed as follows:
81 [14 06 02 04 14 16 18 1A]
81 [---10100 ---00110 ---00010 ---00100 ---10100 ---10110 ---11000 ---11010] --> [10100001 10000100 01001010 01011011 00011010] -->v
81 [A1 84 4A 5B 1A] 3-byte savings.



















